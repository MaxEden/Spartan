<body style="margin: 0;">
    <canvas id="myCanvas" width="200" height="100" style="position: absolute; left: 0; top: 0; z-index: 0; width: 100%; height: 100%; padding: 0; margin: 0; overflow: hidden; "></canvas>
    <canvas id="popupCanvas" width="200" height="100" style="position: absolute; left: 0; top: 0; z-index: 1; width: 100%; height: 100%; padding: 0; margin: 0; overflow: hidden; "></canvas>
</body>
<script>

    const fontBlack = new Image();
    fontBlack.src = "fontBlack";
    const fontWhite = new Image();
    fontWhite.src = "fontWhite";

    const dpr = window.devicePixelRatio || 1;

    var canvas = document.getElementById("myCanvas");    
    var ctx = canvas.getContext("2d");

    var canvas2 = document.getElementById("popupCanvas");
    var ctx2 = canvas2.getContext("2d");

    var mouseX = 0;
    var mouseY = 0;

    class Scroll {
        _scrollArea;
        _scrollHeight;
        _scrollPos;
        _scrollIsActive;
        _scrollRect;
        _defaultPointerPosX;
        _defaultPointerPosY;

        constructor() {
            this._scrollArea = new Rect();
            this._scrollHeight = 0;
            this._scrollPos = 0;
            this._scrollIsActive = false;
            this._scrollRect = new Rect();
        }

        GetScrollRect() {
            if (this._scrollHeight > this._scrollArea.height) {
                var pos = this._scrollPos / this._scrollHeight;
                var part = this._scrollArea.height / this._scrollHeight;

                var length = part * this._scrollArea.height;
                var bit = this._scrollArea.height - length;

                this._scrollRect.X = this._scrollArea.X + this._scrollArea.width - 10;
                this._scrollRect.Y = this._scrollArea.Y + bit * pos;
                this._scrollRect.width = 10;
                this._scrollRect.height = length;

                return true;
            }

            return false;
        }
    }

    class Rect {
        x;
        y;
        width;
        height;

        constructor(x, y, width, height) {
            this.X = x;
            this.Y = y;
            this.width = width;
            this.height = height;
        }

        Contains(posx, posy) {
            return posx >= this.X && posx < this.X + this.width
                && posy >= this.Y && posy < this.Y + this.height;
        }
    }

    var scroll = new Scroll();

    var socket = new WebSocket("ws://" + window.location.hostname + ":4444/");

    const textEncoder = new TextEncoder();

    function resizeCanvas() {
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr + 1;

        drawReader();
    }

    onmousemove = function (e) {
        //const dpr = window.devicePixelRatio || 1;
        var mouseX1 = Math.floor(e.clientX * dpr);
        var mouseY1 = Math.floor(e.clientY * dpr);

        if (mouseX1 == mouseX && mouseY1 == mouseY) return;

        mouseX = mouseX1;
        mouseY = mouseY1;

        drawReader();

        if (socket.readyState == socket.OPEN) {
            const buffer = new ArrayBuffer(24000);
            var writer = new Writer(buffer);
            writer.WriteByte(ClientEvent.Pointer);
            writer.WriteByte(PointerEventType.Moved);
            writer.WriteShort(mouseX);
            writer.WriteShort(mouseY);
            var sendBuffer = writer.ToArray();
            socket.send(sendBuffer);
        }
    }

    onwheel = function (e) {
        if (socket.readyState == socket.OPEN) {
            const buffer = new ArrayBuffer(24000);
            var writer = new Writer(buffer);
            writer.WriteByte(ClientEvent.Pointer);
            writer.WriteByte(PointerEventType.Scrolled);
            writer.WriteShort(e.deltaY);
            var sendBuffer = writer.ToArray();
            socket.send(sendBuffer);
        }
    }

    function drawRect2(rect, r, g, b, a) {
        ctx.fillStyle = `rgba(${r},${g},${b},${a})`;
        ctx.fillRect(rect.X, rect.Y, rect.width, rect.height);
    }

    function drawRect(x, y, width, height, r, g, b, a) {
        ctx.fillStyle = `rgb(${r},${g},${b})`;
        ctx.fillRect(x, y, width, height);
    }

    function drawReader() {
        if (drawBufferSize == null || drawBuffer == null) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        var reader = new Reader(drawBuffer);
        reader.size = drawBufferSize;

        while (!reader.Ended()) {
            var command = reader.ReadByte();
            if (command == Command.Rect) {

                var x = reader.ReadShort();
                var y = reader.ReadShort();
                var width = reader.ReadShort();
                var height = reader.ReadShort();

                var r = reader.ReadByte();
                var g = reader.ReadByte();
                var b = reader.ReadByte();
                var a = reader.ReadByte();

                drawRect(x, y, width, height, r, g, b, a);
            }
            else if (command == Command.RectHoverable) {
                var x = reader.ReadShort();
                var y = reader.ReadShort();
                var width = reader.ReadShort();
                var height = reader.ReadShort();

                var r1 = reader.ReadByte();
                var g1 = reader.ReadByte();
                var b1 = reader.ReadByte();
                var a1 = reader.ReadByte();

                var r2 = reader.ReadByte();
                var g2 = reader.ReadByte();
                var b2 = reader.ReadByte();
                var a2 = reader.ReadByte();

                if (Contains(x, y, width, height, mouseX, mouseY)) {
                    drawRect(x, y, width, height, r2, g2, b2, a2);
                }
                else {
                    drawRect(x, y, width, height, r1, g1, b1, a1);
                }
            }
            else if (command == Command.Text) {
                var pos_x = reader.ReadShort();
                var pos_y = reader.ReadShort();

                var count = reader.ReadShort();
                for (var i = 0; i < count; i++) {

                    var index = reader.ReadUshortComp();

                    var charW = 6;
                    var charH = 12;

                    var y = Math.floor(index / 16);
                    var x = index % 16;

                    var pos_x_char = pos_x + i * charW;

                    ctx.drawImage(fontBlack, x * charW, y * charH, charW, charH, pos_x_char, pos_y, charW, charH);
                }
            }
            else if (command == Command.TextSelection) {
                var pos_x = reader.ReadShort();
                var pos_y = reader.ReadShort();

                var selectionStart = reader.ReadShort();
                var selectionEnd = reader.ReadShort();
                var caretPos = reader.ReadShort();

                if (selectionStart >= 0 && selectionEnd > selectionStart) {
                    var selCount = selectionEnd - selectionStart;
                    drawRect(pos_x + charW * selectionStart, pos_y, charW * selCount, charH, 0, 0, 255, 255);
                }

                var count = reader.ReadShort();
                for (var i = 0; i < count; i++) {

                    var index = reader.ReadUshortComp();

                    var charW = 6;
                    var charH = 12;

                    var y = Math.floor(index / 16);
                    var x = index % 16;

                    var pos_x_char = pos_x + i * charW;
                    if (i >= selectionStart && i < selectionEnd) {
                        ctx.drawImage(fontWhite, x * charW, y * charH, charW, charH, pos_x_char, pos_y, charW, charH);
                    } else {
                        ctx.drawImage(fontBlack, x * charW, y * charH, charW, charH, pos_x_char, pos_y, charW, charH);
                    }
                }

                if (selectionStart < 0 || selectionStart == selectionEnd) {
                    drawRect(pos_x + caretPos * charW, pos_y, 1, charH, 255, 255, 0, 255);
                }
            }
            else if (command == Command.ScrollBegin) {

                reader.ReadRect(scroll._scrollArea);
                scroll._scrollHeight = reader.ReadShort();
                scroll._scrollPos = reader.ReadUshortComp();
                scroll._scrollIsActive = reader.ReadBool();

                ctx.save();
                ctx.beginPath();
                ctx.rect(scroll._scrollArea.X, scroll._scrollArea.Y, scroll._scrollArea.width, scroll._scrollArea.height);
                ctx.clip();
                ctx.translate(scroll._scrollArea.X, scroll._scrollArea.Y - scroll._scrollPos);

                scroll._defaultPointerPosX = mouseX;
                scroll._defaultPointerPosY = mouseY;

                if (scroll._scrollArea.Contains(mouseX, mouseY)) {
                    mouseX -= scroll._scrollArea.X;
                    mouseY -= scroll._scrollArea.Y - scroll._scrollPos;
                } else {
                    mouseX = -1;
                    mouseY = -1;
                }
            }
            else if (command == Command.ScrollEnd) {

                mouseX = scroll._defaultPointerPosX;
                mouseY = scroll._defaultPointerPosY;

                ctx.restore();
                if (scroll.GetScrollRect()) {

                    if (scroll._scrollIsActive)
                    {
                        drawRect2(scroll._scrollRect, 0, 0, 0, 0.75);
                    }
                    else if (scroll._scrollRect.Contains(mouseX, mouseY))
                    {
                        drawRect2(scroll._scrollRect, 0, 0, 0, 0.5);
                    }
                    else
                    {
                        drawRect2(scroll._scrollRect, 0, 0, 0, 0.25);
                    }
                }
            }
        }
    }

    function Contains(x, y, width, height, posx, posy) {
        return posx >= x && posx < x + width
            && posy >= y && posy < y + height;
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    onmousedown = function (e) {
        //return;
        if (socket.readyState == socket.OPEN) {
            const buffer = new ArrayBuffer(2);
            var writer = new Writer(buffer);
            writer.WriteByte(ClientEvent.Pointer);
            writer.WriteByte(PointerEventType.Down);

            var sendBuffer = writer.ToArray();
            socket.send(sendBuffer);
        }
    }

    onmouseup = function (e) {
        //return;
        if (socket.readyState == socket.OPEN) {
            const buffer = new ArrayBuffer(2);
            var writer = new Writer(buffer);
            writer.WriteByte(ClientEvent.Pointer);
            writer.WriteByte(PointerEventType.Up);

            var sendBuffer = writer.ToArray();
            socket.send(sendBuffer);
        }
    }

    window.addEventListener("keydown", (event) => {
        switch (event.key) {
            case "ArrowLeft"://Left Key pressed
                if (socket.readyState == socket.OPEN) {
                    const buffer = new ArrayBuffer(2);
                    var writer = new Writer(buffer);

                    writer.WriteByte(ClientEvent.Text);
                    writer.WriteByte(TextEventType.Left);
                    var sendBuffer = writer.ToArray();
                    socket.send(sendBuffer);
                }
                break;
            case "ArrowRight":
                if (socket.readyState == socket.OPEN) {
                    const buffer = new ArrayBuffer(2);
                    var writer = new Writer(buffer);

                    writer.WriteByte(ClientEvent.Text);
                    writer.WriteByte(TextEventType.Right);
                    var sendBuffer = writer.ToArray();
                    socket.send(sendBuffer);
                }
                break;
            case "Enter":
                if (socket.readyState == socket.OPEN) {
                    const buffer = new ArrayBuffer(2);
                    var writer = new Writer(buffer);

                    writer.WriteByte(ClientEvent.Text);
                    writer.WriteByte(TextEventType.EnterPressed);
                    var sendBuffer = writer.ToArray();
                    socket.send(sendBuffer);
                }
                break;
            case "Delete":
                if (socket.readyState == socket.OPEN) {
                    const buffer = new ArrayBuffer(2);
                    var writer = new Writer(buffer);

                    writer.WriteByte(ClientEvent.Text);
                    writer.WriteByte(TextEventType.Deleted);
                    var sendBuffer = writer.ToArray();
                    socket.send(sendBuffer);
                }
                break;
            case "Backspace":
                if (socket.readyState == socket.OPEN) {
                    const buffer = new ArrayBuffer(2);
                    var writer = new Writer(buffer);

                    writer.WriteByte(ClientEvent.Text);
                    writer.WriteByte(TextEventType.Backspaced);
                    var sendBuffer = writer.ToArray();
                    socket.send(sendBuffer);
                }
                break;
        }

        if (event.key.length == 1) {
            if (socket.readyState == socket.OPEN) {
                const buffer = new ArrayBuffer(8);
                var writer = new Writer(buffer);
                writer.WriteByte(ClientEvent.Text);
                writer.WriteByte(TextEventType.Entered);

                let encoded = textEncoder.encode(event.key);
                writer.WriteByte(encoded.length);

                var dst = new Uint8Array(buffer, writer.pos, encoded.length);
                dst.set(encoded);
                writer.pos += encoded.length;


                var sendBuffer = writer.ToArray();
                socket.send(sendBuffer);
            }
        }
    });

    addEventListener("copy", (event) => {
        if (socket.readyState == socket.OPEN) {
            const buffer = new ArrayBuffer(2);
            var writer = new Writer(buffer);
            writer.WriteByte(TextEventType.Copy);
            var sendBuffer = writer.ToArray();
            socket.send(sendBuffer);
        }
    });

    socket.onopen = function () {
        console.log("open");

    };

    var drawBuffer = new ArrayBuffer(24000);
    var drawBufferSize = 0;

    socket.onmessage = function (e) {
        e.data.arrayBuffer().then(buffer => {
            var reader = new Reader(buffer);
            var sliceSize = reader.ReadShort();
            var countStartSame = reader.ReadShort();
            var countEndSame = reader.ReadShort();

            var slice = buffer.slice(reader.pos, reader.pos + sliceSize);
            var u8slice = new Uint8Array(slice);

            var newSize = 0;
            var newDrawBuffer = new ArrayBuffer(24000);
            var newU8 = new Uint8Array(newDrawBuffer);

            if (countStartSame > 0) {
                var u8start = new Uint8Array(drawBuffer, 0, countStartSame);
                newU8.set(u8start, 0);
                newSize += countStartSame;
            }

            newU8.set(u8slice, newSize);
            newSize += sliceSize;

            if (countEndSame > 0) {
                var u8end = new Uint8Array(drawBuffer, drawBufferSize - countEndSame, countEndSame);
                newU8.set(u8end, newSize);
                newSize += countEndSame;
            }

            drawBufferSize = newSize;
            drawBuffer = newDrawBuffer;

            drawReader();
        });
    };
    socket.onclose = function () { console.log("closed"); };

    class Writer {

        view;
        pos = 0;
        capacity = 0;
        buffer;

        constructor(data) {
            this.buffer = data;
            this.capacity = data.byteLength;
            this.view = new DataView(data);
            this.pos = 0;
        }

        WriteByte(value) {
            this.pos += 1;
            return this.view.setUint8(this.pos - 1, value);
        }

        WriteShort(value) {
            this.pos += 2;
            return this.view.setInt16(this.pos - 2, value, true);
        }

        WriteInt32(value) {
            this.pos += 4;
            return this.view.setInt32(this.pos - 4, value, true);
        }

        WriteFloat(value) {
            this.pos += 4;
            return this.view.setFloat32(this.pos - 4, value, true);
        }

        ToArray() {
            var sendBuffer = this.buffer.slice(0, this.pos);
            return sendBuffer;
        }
    }

    class Reader {

        view;
        pos = 0;
        size = 0;

        Ended() {
            return this.pos >= this.size;
        }

        constructor(data) {
            this.size = data.byteLength;
            this.view = new DataView(data);
            this.pos = 0;
        }

        ReadByte() {
            this.pos += 1;
            return this.view.getUint8(this.pos - 1);
        }

        ReadBool() {
            this.pos += 1;
            return this.view.getUint8(this.pos - 1) == 1;
        }

        ReadShort() {
            this.pos += 2;
            return this.view.getInt16(this.pos - 2, true);
        }

        ReadInt32() {
            this.pos += 4;
            return this.view.getInt32(this.pos - 4, true);
        }

        ReadFloat() {
            this.pos += 4;
            return this.view.getFloat32(this.pos - 4, true);
        }

        ReadUshortComp() {
            var index = this.ReadByte();
            if (index > 127) {
                var b = this.ReadByte();
                index = (index & 127) << 8 | b;
            }

            return index;
        }

        ReadRect(rect) {
            rect.X = this.ReadShort();
            rect.Y = this.ReadShort();
            rect.width = this.ReadShort();
            rect.height = this.ReadShort();
        }
    }

    class Command {
        static Rect = 1;
        static Text = 2;
        static RectHoverable = 3;
        static RectBlinking = 4;
        static TextSelection = 5;
        static ScrollBegin = 6;
        static ScrollEnd = 7;
    }

    class ClientEvent {
        static Pointer = 1;
        static Text = 2;
    }

    class PointerEventType {
        static Enter = 0;
        static Moved = 1;
        static Down = 2;
        static Up = 3;
        static Left = 4;
        static Scrolled = 5;
    }

    class TextEventType {
        static None = 0;
        static Entered = 1;
        static Deleted = 2;
        static Backspaced = 3;
        static EnterPressed = 4;
        static Right = 5;
        static Left = 6;
        static Copy = 7;
    }

</script>